
/*
 * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT
 * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 * @author Himanshu Neema
 * @author Harmon Nine
 */

// This code has been generated by the C2W code generator.
// Do not edit manually!

/*
 * 	NOTE:  ALL "if" STATEMENTS IN THIS CODE THAT HAD THE FORM:
 *
 *  if (condition) statement;
 *
 *	OR
 *
 *  if (condition) statement1;
 *  else           statement2;
 *
 *  HAVE BEEN CONVERTED TO THE FORMS:
 *
 *  if (condition) {
 *		statement;
 *	}
 *
 *	AND
 *
 *  if (condition) {
 *		statement1;
 *	} else {
 *		statement2;
 *	}
 *
 *	RESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM
 *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.
 *  -- H.S.N.
 *
 */

#ifndef _NetworkPacket_CLASS
#define _NetworkPacket_CLASS

#include "InteractionRoot.hpp"


class NetworkPacket : public InteractionRoot {

private:
    static int get_handle(void) {
        return 1;
    }

    static StringVector &getDatamemberNames(void) {
        static StringVector stringVector;
        return stringVector;
    }

public:
    static std::string get_class_name( void ) { return "InteractionRoot"; }

    static StringVector get_parameter_names(void) {
        return getDatamemberNames();
    }

    static bool static_init(void) {

        getDatamemberNames().push_back( "packetType" );
        getDatamemberNames().push_back( "receiverHost" );
        getDatamemberNames().push_back( "data" );
        getDatamemberNames().push_back( "receiverAppIndex" );
        getDatamemberNames().push_back( "receiverHostApp" );
        getDatamemberNames().push_back( "senderHostApp" );
        getDatamemberNames().push_back( "numBytes" );
        getDatamemberNames().push_back( "senderHost" );
        getDatamemberNames().push_back( "receiverAppInterface" );
        getDatamemberNames().push_back( "senderAppIndex" );

        return true;
    }

	typedef InteractionRoot Super;
	typedef boost::shared_ptr< NetworkPacket > SP;

	NetworkPacket( void ) { }
	virtual ~NetworkPacket(void) { }
	
	static bool match( int handle ) { return handle == get_handle(); }

	virtual int getClassHandle( void ) const override { return get_handle(); }
    virtual std::string getClassName( void ) const override { return get_class_name(); }

	virtual StringVector getParameterNames( void ) const override { return get_parameter_names(); }

private:
	
	std::string _packetType;
	std::string _receiverHost;
	std::string _data;
	int _receiverAppIndex;
	std::string _receiverHostApp;
	std::string _senderHostApp;
	int _numBytes;
	std::string _senderHost;
	std::string _receiverAppInterface;
	int _senderAppIndex;
	
public:
		
	void set_packetType( const std::string & packetType ) { _packetType = packetType; }
	const std::string & get_packetType( void ) const { return _packetType; }
	
	void set_receiverHost( const std::string & receiverHost ) { _receiverHost = receiverHost; }
	const std::string & get_receiverHost( void ) const { return _receiverHost; }
	
	void set_data( const std::string & data ) { _data = data; }
	const std::string & get_data( void ) const { return _data; }
	
	void set_receiverAppIndex( int receiverAppIndex ) { _receiverAppIndex = receiverAppIndex; }
	int get_receiverAppIndex( void ) const { return _receiverAppIndex; }
	
	void set_receiverHostApp( const std::string & receiverHostApp ) { _receiverHostApp = receiverHostApp; }
	const std::string & get_receiverHostApp( void ) const { return _receiverHostApp; }
	
	void set_senderHostApp( const std::string & senderHostApp ) { _senderHostApp = senderHostApp; }
	const std::string & get_senderHostApp( void ) const { return _senderHostApp; }
	
	void set_numBytes( int numBytes ) { _numBytes = numBytes; }
	int get_numBytes( void ) const { return _numBytes; }
	
	void set_senderHost( const std::string & senderHost ) { _senderHost = senderHost; }
	const std::string & get_senderHost( void ) const { return _senderHost; }
	
	void set_receiverAppInterface( const std::string & receiverAppInterface ) { _receiverAppInterface = receiverAppInterface; }
	const std::string & get_receiverAppInterface( void ) const { return _receiverAppInterface; }
	
	void set_senderAppIndex( int senderAppIndex ) { _senderAppIndex = senderAppIndex; }
	int get_senderAppIndex( void ) const { return _senderAppIndex; }
	
    TypeMedley getParameter( const std::string &datamemberName ) const override {

        if ( "packetType" == datamemberName ) {
            return TypeMedley( get_packetType() );
        }
        else if ( "receiverHost" == datamemberName ) {
            return TypeMedley( get_receiverHost() );
        }
        else if ( "data" == datamemberName ) {
            return TypeMedley( get_data() );
        }
        else if ( "receiverAppIndex" == datamemberName ) {
            return TypeMedley( get_receiverAppIndex() );
        }
        else if ( "receiverHostApp" == datamemberName ) {
            return TypeMedley( get_receiverHostApp() );
        }
        else if ( "senderHostApp" == datamemberName ) {
            return TypeMedley( get_senderHostApp() );
        }
        else if ( "numBytes" == datamemberName ) {
            return TypeMedley( get_numBytes() );
        }
        else if ( "senderHost" == datamemberName ) {
            return TypeMedley( get_senderHost() );
        }
        else if ( "receiverAppInterface" == datamemberName ) {
            return TypeMedley( get_receiverAppInterface() );
        }
        else if ( "senderAppIndex" == datamemberName ) {
            return TypeMedley( get_senderAppIndex() );
        } else {
            return Super::getParameter( datamemberName );
        }
    }

};

typedef NetworkPacket::SP NetworkPacketSP;

static bool call_NetworkPacket_static_init = NetworkPacket::static_init();

//std::ostream &operator<<( std::ostream &os, NetworkPacket::SP entitySP );
//std::ostream &operator<<( std::ostream &os, const NetworkPacket &entity );

#endif
